#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif

#include <iostream>
#include <cmath>
using namespace std;


   // GLOBALS (values from user)


int x_start = 50;
int y_start = 50;
int x_end   = 400;
int y_end   = 300;
int LINE_WIDTH = 3;   // user chooses this

const int WINDOW_W = 500;
const int WINDOW_H = 500;

/*
    Put ONE pixel at (x,y)
*/
void putPixel(int x, int y)
{
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
}


void drawThickPixelBar(int x, int y, bool steep, int thickness)
{
    int half = thickness / 2; // integer division handles odd/even

    if (!steep)
    {
        // shallow line -> thicken in Y direction
        for (int o = -half; o <= half; o++)
        {
            putPixel(x, y + o);
        }
    }
    else
    {
        // steep line -> thicken in X direction
        for (int o = -half; o <= half; o++)
        {
            putPixel(x + o, y);
        }
    }
}

/*
    Generalized Bresenham that works for
    all octants (all slopes, all directions)
    AND draws thickness.
*/
void bresenhamLine(int x1, int y1, int x2, int y2, int thickness)
{
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);

    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;

    // If dy > dx, slope magnitude > 1  -> "steep"
    bool steep = (dy > dx);

    // Classic Bresenham-style error term,
    // but we branch logic for steep/non-steep
    int err = (steep ? 2*dx - dy : 2*dy - dx);

    int x = x1;
    int y = y1;

    int steps = steep ? dy : dx;

    for (int i = 0; i <= steps; i++)
    {
        // draw a thick bar at this pixel
        drawThickPixelBar(x, y, steep, thickness);

        if (!steep)
        {
            // shallow case: we step mostly in X
            if (err > 0)
            {
                y += sy;
                err -= 2 * dx;
            }
            x += sx;
            err += 2 * dy;
        }
        else
        {
            // steep case: we step mostly in Y
            if (err > 0)
            {
                x += sx;
                err -= 2 * dy;
            }
            y += sy;
            err += 2 * dx;
        }
    }
}

/*
    GLUT display callback
*/
void display()
{
    glClear(GL_COLOR_BUFFER_BIT);

    // draw axis lines (gray)
    glColor3f(0.3f, 0.3f, 0.3f);
    glBegin(GL_LINES);
        // horizontal mid
        glVertex2i(0, WINDOW_H/2);
        glVertex2i(WINDOW_W, WINDOW_H/2);
        // vertical mid
        glVertex2i(WINDOW_W/2, 0);
        glVertex2i(WINDOW_W/2, WINDOW_H);
    glEnd();

    // draw our thick line (white)
    glColor3f(1.0f, 1.0f, 1.0f);
    bresenhamLine(x_start, y_start, x_end, y_end, LINE_WIDTH);

    glFlush();
}

/*
    Basic GL setup
*/
void initGL()
{
    glClearColor(0.0, 0.0, 0.0, 1.0);   // black background
    glPointSize(3.0);                   // pixel size for plotting

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, WINDOW_W, 0, WINDOW_H); // left,right,bottom,top
}


int main(int argc, char** argv)
{
    cout << "Enter x1 y1 x2 y2: ";
    cin >> x_start >> y_start >> x_end >> y_end;

    cout << "Enter line thickness (e.g. 1,3,5,9): ";
    cin >> LINE_WIDTH;

    if (LINE_WIDTH < 1) LINE_WIDTH = 1; // safety

    // GLUT init
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(WINDOW_W, WINDOW_H);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Bresenham Line (All Slopes, Thick)");

    initGL();
    glutDisplayFunc(display);

    glutMainLoop();
    return 0;
}
